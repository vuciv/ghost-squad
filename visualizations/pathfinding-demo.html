<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>A* Pathfinding Visualization - Ghost Squad</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Courier New', monospace;
      background: #0a0a0a;
      color: #00ff00;
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      padding: 20px;
    }

    #container {
      background: #1a1a1a;
      border: 3px solid #00ff00;
      border-radius: 10px;
      padding: 30px;
      max-width: 1200px;
      box-shadow: 0 0 30px rgba(0, 255, 0, 0.3);
    }

    h1 {
      text-align: center;
      color: #ffff00;
      text-shadow: 0 0 10px rgba(255, 255, 0, 0.5);
      margin-bottom: 10px;
      font-size: 32px;
    }

    .subtitle {
      text-align: center;
      color: #00ffff;
      margin-bottom: 30px;
      font-size: 14px;
    }

    #canvas {
      display: block;
      margin: 0 auto 20px;
      border: 2px solid #333;
      background: #000;
      image-rendering: pixelated;
      image-rendering: crisp-edges;
    }

    .controls {
      display: flex;
      gap: 15px;
      justify-content: center;
      flex-wrap: wrap;
      margin-bottom: 20px;
    }

    button {
      background: #00ff00;
      color: #000;
      border: none;
      padding: 12px 24px;
      font-family: 'Courier New', monospace;
      font-weight: bold;
      font-size: 14px;
      cursor: pointer;
      border-radius: 5px;
      transition: all 0.2s;
      box-shadow: 0 4px 0 #00aa00;
    }

    button:hover {
      background: #00ff00;
      transform: translateY(-2px);
      box-shadow: 0 6px 0 #00aa00;
    }

    button:active {
      transform: translateY(2px);
      box-shadow: 0 2px 0 #00aa00;
    }

    button:disabled {
      background: #555;
      color: #999;
      cursor: not-allowed;
      box-shadow: 0 4px 0 #333;
    }

    .stats {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 15px;
      margin-bottom: 20px;
    }

    .stat-box {
      background: #0d0d0d;
      border: 2px solid #333;
      border-radius: 8px;
      padding: 15px;
      text-align: center;
    }

    .stat-label {
      color: #00ffff;
      font-size: 12px;
      margin-bottom: 5px;
    }

    .stat-value {
      color: #ffff00;
      font-size: 24px;
      font-weight: bold;
      text-shadow: 0 0 8px rgba(255, 255, 0, 0.5);
    }

    .legend {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
      gap: 10px;
      background: #0d0d0d;
      padding: 15px;
      border-radius: 8px;
      border: 2px solid #333;
    }

    .legend-item {
      display: flex;
      align-items: center;
      gap: 10px;
      font-size: 12px;
    }

    .legend-color {
      width: 20px;
      height: 20px;
      border: 1px solid #666;
      border-radius: 3px;
    }

    .info {
      background: #0d0d0d;
      border: 2px solid #ffff00;
      border-radius: 8px;
      padding: 15px;
      margin-top: 20px;
      font-size: 12px;
      line-height: 1.6;
    }

    .info h3 {
      color: #ffff00;
      margin-bottom: 10px;
      font-size: 16px;
    }

    .info code {
      background: #000;
      padding: 2px 6px;
      border-radius: 3px;
      color: #00ff00;
    }
  </style>
</head>
<body>
  <div id="container">
    <h1>üéÆ A* PATHFINDING VISUALIZATION</h1>
    <div class="subtitle">Watch how Pacman finds the optimal path to pellets</div>

    <canvas id="canvas" width="840" height="1050"></canvas>

    <div class="controls">
      <button id="btnStep">Step Forward</button>
      <button id="btnPlay">‚ñ∂ Play</button>
      <button id="btnPause" disabled>‚è∏ Pause</button>
      <button id="btnReset">üîÑ Reset</button>
      <button id="btnSpeed">Speed: 1x</button>
    </div>

    <div class="stats">
      <div class="stat-box">
        <div class="stat-label">Nodes Explored</div>
        <div class="stat-value" id="nodesExplored">0</div>
      </div>
      <div class="stat-box">
        <div class="stat-label">Path Length</div>
        <div class="stat-value" id="pathLength">-</div>
      </div>
      <div class="stat-box">
        <div class="stat-label">Algorithm Status</div>
        <div class="stat-value" id="status" style="font-size: 18px;">READY</div>
      </div>
    </div>

    <div class="legend">
      <div class="legend-item">
        <div class="legend-color" style="background: #2121de;"></div>
        <span>Wall</span>
      </div>
      <div class="legend-item">
        <div class="legend-color" style="background: #ffff00;"></div>
        <span>üü° Pacman</span>
      </div>
      <div class="legend-item">
        <div class="legend-color" style="background: #ff6b6b;"></div>
        <span>üî¥ Target Pellet</span>
      </div>
      <div class="legend-item">
        <div class="legend-color" style="background: #4ecdc4;"></div>
        <span>Exploring</span>
      </div>
      <div class="legend-item">
        <div class="legend-color" style="background: #95e1d3;"></div>
        <span>Explored</span>
      </div>
      <div class="legend-item">
        <div class="legend-color" style="background: #00ff00;"></div>
        <span>Final Path</span>
      </div>
    </div>

    <div class="info">
      <h3>How A* Pathfinding Works</h3>
      <p>
        <strong>1. Start:</strong> Begin at Pacman's position<br>
        <strong>2. Explore:</strong> Check neighboring tiles, calculating <code>f = g + h</code> where:<br>
        &nbsp;&nbsp;&nbsp;&nbsp;‚Ä¢ <code>g</code> = distance from start<br>
        &nbsp;&nbsp;&nbsp;&nbsp;‚Ä¢ <code>h</code> = estimated distance to goal (heuristic)<br>
        <strong>3. Expand:</strong> Always expand the node with lowest <code>f</code> score<br>
        <strong>4. Repeat:</strong> Until we reach the target<br>
        <strong>5. Reconstruct:</strong> Trace back from goal to start for final path<br><br>

        <strong>Why it's optimal:</strong> A* guarantees the shortest path because it intelligently
        prioritizes promising directions using the heuristic, but never skips a better path.
      </p>
    </div>
  </div>

  <script>
    // Simplified maze (smaller for visualization)
    const MAZE = [
      [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
      [0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,0],
      [0,1,0,0,0,0,1,0,0,0,0,0,1,0,0,1,0,0,0,0,0,1,0,0,0,0,1,0],
      [0,2,0,0,0,0,1,0,0,0,0,0,1,0,0,1,0,0,0,0,0,1,0,0,0,0,2,0],
      [0,1,0,0,0,0,1,0,0,0,0,0,1,0,0,1,0,0,0,0,0,1,0,0,0,0,1,0],
      [0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0],
      [0,1,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,1,0],
      [0,1,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,1,0],
      [0,1,1,1,1,1,1,0,0,1,1,1,1,0,0,1,1,1,1,0,0,1,1,1,1,1,1,0],
      [0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0],
      [0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0],
      [0,0,0,0,0,0,1,0,0,1,1,1,1,1,1,1,1,1,1,0,0,1,0,0,0,0,0,0],
      [0,0,0,0,0,0,1,0,0,1,0,0,0,3,3,0,0,0,1,0,0,1,0,0,0,0,0,0],
      [0,0,0,0,0,0,1,0,0,1,0,3,3,3,3,3,3,0,1,0,0,1,0,0,0,0,0,0],
      [3,1,1,1,1,1,1,1,1,1,0,3,3,3,3,3,3,0,1,1,1,1,1,1,1,1,1,3],
      [0,0,0,0,0,0,1,0,0,1,0,3,3,3,3,3,3,0,1,0,0,1,0,0,0,0,0,0],
      [0,0,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,0,0],
      [0,0,0,0,0,0,1,0,0,1,1,1,1,1,1,1,1,1,1,0,0,1,0,0,0,0,0,0],
      [0,0,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,0,0],
      [0,0,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,0,0],
      [0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,0],
      [0,1,0,0,0,0,1,0,0,0,0,0,1,0,0,1,0,0,0,0,0,1,0,0,0,0,1,0],
      [0,1,0,0,0,0,1,0,0,0,0,0,1,0,0,1,0,0,0,0,0,1,0,0,0,0,1,0],
      [0,2,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,2,0],
      [0,0,0,1,0,0,1,0,0,1,0,0,0,0,0,0,0,0,1,0,0,1,0,0,1,0,0,0],
      [0,0,0,1,0,0,1,0,0,1,0,0,0,0,0,0,0,0,1,0,0,1,0,0,1,0,0,0],
      [0,1,1,1,1,1,1,0,0,1,1,1,1,0,0,1,1,1,1,0,0,1,1,1,1,1,1,0],
      [0,1,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,1,0],
      [0,1,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,1,0],
      [0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0],
      [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
    ];

    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const TILE_SIZE = 30;

    let pacman = { x: 14, y: 23 };
    let target = { x: 3, y: 3 }; // Power pellet
    let openSet = [];
    let closedSet = [];
    let currentNode = null;
    let finalPath = [];
    let step = 0;
    let isPlaying = false;
    let speed = 1;
    let interval = null;

    // A* Algorithm state
    let gScore = {};
    let fScore = {};
    let cameFrom = {};

    function initAStar() {
      openSet = [pacman];
      closedSet = [];
      currentNode = null;
      finalPath = [];
      step = 0;
      gScore = {};
      fScore = {};
      cameFrom = {};

      const startKey = `${pacman.x},${pacman.y}`;
      gScore[startKey] = 0;
      fScore[startKey] = heuristic(pacman, target);

      updateStats();
    }

    function heuristic(a, b) {
      return Math.abs(a.x - b.x) + Math.abs(a.y - b.y);
    }

    function getNeighbors(node) {
      const neighbors = [];
      const dirs = [
        { x: 0, y: -1 },
        { x: 0, y: 1 },
        { x: -1, y: 0 },
        { x: 1, y: 0 }
      ];

      for (const dir of dirs) {
        const nx = node.x + dir.x;
        const ny = node.y + dir.y;

        if (ny >= 0 && ny < MAZE.length && nx >= 0 && nx < MAZE[0].length) {
          if (MAZE[ny][nx] !== 0) {
            neighbors.push({ x: nx, y: ny });
          }
        }
      }

      return neighbors;
    }

    function stepAStar() {
      if (openSet.length === 0) {
        document.getElementById('status').textContent = 'NO PATH';
        return false;
      }

      // Find node with lowest f score
      let lowestF = Infinity;
      let lowestIndex = 0;
      for (let i = 0; i < openSet.length; i++) {
        const key = `${openSet[i].x},${openSet[i].y}`;
        const f = fScore[key] || Infinity;
        if (f < lowestF) {
          lowestF = f;
          lowestIndex = i;
        }
      }

      currentNode = openSet[lowestIndex];
      const currentKey = `${currentNode.x},${currentNode.y}`;

      // Check if we reached the goal
      if (currentNode.x === target.x && currentNode.y === target.y) {
        reconstructPath();
        document.getElementById('status').textContent = 'FOUND!';
        return false;
      }

      // Move current from open to closed
      openSet.splice(lowestIndex, 1);
      closedSet.push(currentNode);

      // Check neighbors
      const neighbors = getNeighbors(currentNode);
      for (const neighbor of neighbors) {
        const neighborKey = `${neighbor.x},${neighbor.y}`;

        // Skip if in closed set
        if (closedSet.some(n => n.x === neighbor.x && n.y === neighbor.y)) {
          continue;
        }

        const tentativeG = (gScore[currentKey] || Infinity) + 1;

        // Add to open set if not there
        if (!openSet.some(n => n.x === neighbor.x && n.y === neighbor.y)) {
          openSet.push(neighbor);
        } else if (tentativeG >= (gScore[neighborKey] || Infinity)) {
          continue; // Not a better path
        }

        // This is the best path so far
        cameFrom[neighborKey] = currentNode;
        gScore[neighborKey] = tentativeG;
        fScore[neighborKey] = tentativeG + heuristic(neighbor, target);
      }

      step++;
      updateStats();
      return true;
    }

    function reconstructPath() {
      finalPath = [];
      let current = target;
      while (current) {
        finalPath.unshift(current);
        const key = `${current.x},${current.y}`;
        current = cameFrom[key];
      }
    }

    function updateStats() {
      document.getElementById('nodesExplored').textContent = closedSet.length;
      document.getElementById('pathLength').textContent = finalPath.length > 0 ? finalPath.length - 1 : '-';
      document.getElementById('status').textContent = finalPath.length > 0 ? 'FOUND!' : 'SEARCHING...';
    }

    function draw() {
      ctx.fillStyle = '#000';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // Draw maze
      for (let y = 0; y < MAZE.length; y++) {
        for (let x = 0; x < MAZE[y].length; x++) {
          const cell = MAZE[y][x];

          if (cell === 0) {
            // Wall
            ctx.fillStyle = '#2121de';
            ctx.fillRect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
            ctx.strokeStyle = '#1515aa';
            ctx.strokeRect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
          }
        }
      }

      // Draw closed set (explored)
      ctx.fillStyle = 'rgba(149, 225, 211, 0.3)';
      for (const node of closedSet) {
        if (node.x !== pacman.x || node.y !== pacman.y) {
          ctx.fillRect(node.x * TILE_SIZE + 2, node.y * TILE_SIZE + 2, TILE_SIZE - 4, TILE_SIZE - 4);
        }
      }

      // Draw open set (exploring)
      ctx.fillStyle = 'rgba(78, 205, 196, 0.5)';
      for (const node of openSet) {
        ctx.fillRect(node.x * TILE_SIZE + 2, node.y * TILE_SIZE + 2, TILE_SIZE - 4, TILE_SIZE - 4);
      }

      // Draw final path
      if (finalPath.length > 0) {
        ctx.strokeStyle = '#00ff00';
        ctx.lineWidth = 4;
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';

        ctx.beginPath();
        for (let i = 0; i < finalPath.length; i++) {
          const node = finalPath[i];
          const cx = node.x * TILE_SIZE + TILE_SIZE / 2;
          const cy = node.y * TILE_SIZE + TILE_SIZE / 2;

          if (i === 0) {
            ctx.moveTo(cx, cy);
          } else {
            ctx.lineTo(cx, cy);
          }
        }
        ctx.stroke();

        // Draw arrow heads along path
        ctx.fillStyle = '#00ff00';
        for (let i = 1; i < finalPath.length; i++) {
          const from = finalPath[i - 1];
          const to = finalPath[i];
          const cx = to.x * TILE_SIZE + TILE_SIZE / 2;
          const cy = to.y * TILE_SIZE + TILE_SIZE / 2;

          const dx = to.x - from.x;
          const dy = to.y - from.y;
          const angle = Math.atan2(dy, dx);

          ctx.save();
          ctx.translate(cx, cy);
          ctx.rotate(angle);
          ctx.beginPath();
          ctx.moveTo(5, 0);
          ctx.lineTo(-3, -3);
          ctx.lineTo(-3, 3);
          ctx.closePath();
          ctx.fill();
          ctx.restore();
        }
      }

      // Draw current exploring node
      if (currentNode && finalPath.length === 0) {
        ctx.fillStyle = 'rgba(255, 107, 107, 0.7)';
        ctx.fillRect(currentNode.x * TILE_SIZE + 4, currentNode.y * TILE_SIZE + 4, TILE_SIZE - 8, TILE_SIZE - 8);
      }

      // Draw target (power pellet)
      ctx.fillStyle = '#ff6b6b';
      ctx.beginPath();
      ctx.arc(target.x * TILE_SIZE + TILE_SIZE / 2, target.y * TILE_SIZE + TILE_SIZE / 2, 10, 0, Math.PI * 2);
      ctx.fill();
      ctx.strokeStyle = '#ff4444';
      ctx.lineWidth = 2;
      ctx.stroke();

      // Draw Pacman
      ctx.fillStyle = '#ffff00';
      ctx.beginPath();
      ctx.arc(pacman.x * TILE_SIZE + TILE_SIZE / 2, pacman.y * TILE_SIZE + TILE_SIZE / 2, 12, 0.2 * Math.PI, 1.8 * Math.PI);
      ctx.lineTo(pacman.x * TILE_SIZE + TILE_SIZE / 2, pacman.y * TILE_SIZE + TILE_SIZE / 2);
      ctx.fill();

      // Draw grid
      ctx.strokeStyle = 'rgba(255, 255, 255, 0.05)';
      ctx.lineWidth = 1;
      for (let x = 0; x <= MAZE[0].length; x++) {
        ctx.beginPath();
        ctx.moveTo(x * TILE_SIZE, 0);
        ctx.lineTo(x * TILE_SIZE, canvas.height);
        ctx.stroke();
      }
      for (let y = 0; y <= MAZE.length; y++) {
        ctx.beginPath();
        ctx.moveTo(0, y * TILE_SIZE);
        ctx.lineTo(canvas.width, y * TILE_SIZE);
        ctx.stroke();
      }
    }

    // Controls
    document.getElementById('btnStep').addEventListener('click', () => {
      if (finalPath.length === 0) {
        stepAStar();
        draw();
      }
    });

    document.getElementById('btnPlay').addEventListener('click', () => {
      isPlaying = true;
      document.getElementById('btnPlay').disabled = true;
      document.getElementById('btnPause').disabled = false;
      document.getElementById('btnStep').disabled = true;

      const delays = { 1: 200, 2: 100, 3: 50 };
      interval = setInterval(() => {
        if (!stepAStar() || finalPath.length > 0) {
          clearInterval(interval);
          isPlaying = false;
          document.getElementById('btnPlay').disabled = false;
          document.getElementById('btnPause').disabled = true;
          document.getElementById('btnStep').disabled = false;
        }
        draw();
      }, delays[speed]);
    });

    document.getElementById('btnPause').addEventListener('click', () => {
      clearInterval(interval);
      isPlaying = false;
      document.getElementById('btnPlay').disabled = false;
      document.getElementById('btnPause').disabled = true;
      document.getElementById('btnStep').disabled = false;
    });

    document.getElementById('btnReset').addEventListener('click', () => {
      clearInterval(interval);
      isPlaying = false;
      document.getElementById('btnPlay').disabled = false;
      document.getElementById('btnPause').disabled = true;
      document.getElementById('btnStep').disabled = false;
      initAStar();
      draw();
    });

    document.getElementById('btnSpeed').addEventListener('click', function() {
      speed = speed === 3 ? 1 : speed + 1;
      this.textContent = `Speed: ${speed}x`;

      if (isPlaying) {
        clearInterval(interval);
        document.getElementById('btnPlay').click();
      }
    });

    // Initialize
    initAStar();
    draw();
  </script>
</body>
</html>
