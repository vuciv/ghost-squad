<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>A* Pathfinding Algorithm - Pac-Man AI Visualization</title>
    <style>
        body {
            font-family: 'Courier New', monospace;
            background: #000;
            color: #0f0;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            margin: 0;
        }
        h1 {
            color: #ff0;
            text-shadow: 0 0 10px #ff0;
            margin-bottom: 10px;
        }
        .description {
            max-width: 800px;
            text-align: center;
            margin-bottom: 20px;
            line-height: 1.6;
            color: #0ff;
        }
        .controls {
            margin: 20px 0;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            justify-content: center;
        }
        button {
            background: #222;
            color: #0f0;
            border: 2px solid #0f0;
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            transition: all 0.3s;
        }
        button:hover {
            background: #0f0;
            color: #000;
            box-shadow: 0 0 10px #0f0;
        }
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        #canvas {
            border: 3px solid #2121de;
            box-shadow: 0 0 20px #2121de;
            margin: 20px 0;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }
        .legend {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
            justify-content: center;
            margin-top: 20px;
        }
        .legend-item {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .legend-color {
            width: 30px;
            height: 30px;
            border: 2px solid #0f0;
        }
        .stats {
            margin-top: 20px;
            font-size: 18px;
            text-align: center;
        }
        .stat-value {
            color: #ff0;
            font-weight: bold;
        }
        .explanation {
            max-width: 800px;
            text-align: left;
            margin-top: 30px;
            padding: 20px;
            border: 2px solid #0f0;
            background: #001100;
        }
        .explanation h2 {
            color: #ff0;
            margin-top: 0;
        }
        .explanation code {
            color: #0ff;
            background: #002200;
            padding: 2px 6px;
            border-radius: 3px;
        }
        label {
            color: #0ff;
        }
        select {
            background: #222;
            color: #0f0;
            border: 2px solid #0f0;
            padding: 5px;
            font-family: 'Courier New', monospace;
        }
    </style>
</head>
<body>
    <h1>A* PATHFINDING ALGORITHM</h1>
    <div class="description">
        Used by AggressiveAI to hunt frightened ghosts during power pellet mode.
        Watch as A* explores the maze to find the optimal path!
    </div>

    <div class="controls">
        <button onclick="startSearch()">Start A* Search</button>
        <button onclick="stepSearch()">Step Forward</button>
        <button onclick="resetSearch()">Reset</button>
        <button onclick="randomizePoints()">Randomize Start/Goal</button>
        <label style="color: #0ff; margin-left: 20px;">
            Speed:
            <select id="speedControl">
                <option value="500">Slow</option>
                <option value="100" selected>Medium</option>
                <option value="20">Fast</option>
                <option value="0">Instant</option>
            </select>
        </label>
    </div>

    <canvas id="canvas" width="560" height="700"></canvas>

    <div class="stats">
        <div>Nodes Evaluated: <span class="stat-value" id="nodesEvaluated">0</span></div>
        <div>Path Length: <span class="stat-value" id="pathLength">-</span></div>
        <div>Status: <span class="stat-value" id="status">Ready</span></div>
    </div>

    <div class="legend">
        <div class="legend-item">
            <div class="legend-color" style="background: #000; border-color: #2121de;"></div>
            <span>Wall</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: rgba(0, 255, 255, 0.3);"></div>
            <span>Explored</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: rgba(255, 255, 0, 0.3);"></div>
            <span>Frontier</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #0f0;"></div>
            <span>Final Path</span>
        </div>
    </div>

    <div class="explanation">
        <h2>How A* Works</h2>
        <p><strong>A*</strong> is a graph traversal algorithm that finds the shortest path between two points using <code>f = g + h</code>.</p>

        <h3>The Algorithm:</h3>
        <ul>
            <li><strong>g-score:</strong> Actual distance from start</li>
            <li><strong>h-score (heuristic):</strong> Estimated distance to goal (Manhattan distance)</li>
            <li><strong>f-score:</strong> <code>g + h</code> - Total estimated cost through this node</li>
            <li>Always explores the most promising node (lowest f-score)</li>
            <li>Guarantees shortest path if heuristic is admissible</li>
        </ul>

        <h3>Why A* for Ghost Hunting?</h3>
        <ul>
            <li><strong>Optimal:</strong> Guarantees shortest path to catch ghosts</li>
            <li><strong>Efficient:</strong> The heuristic guides search toward the goal</li>
            <li><strong>Fast enough:</strong> Can recompute paths in real-time as ghosts move</li>
        </ul>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        // Actual Pac-Man maze layout (0 = wall, 1-3 = walkable)
        const MAZE = [
            [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
            [0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,0],
            [0,1,0,0,0,0,1,0,0,0,0,0,1,0,0,1,0,0,0,0,0,1,0,0,0,0,1,0],
            [0,2,0,0,0,0,1,0,0,0,0,0,1,0,0,1,0,0,0,0,0,1,0,0,0,0,2,0],
            [0,1,0,0,0,0,1,0,0,0,0,0,1,0,0,1,0,0,0,0,0,1,0,0,0,0,1,0],
            [0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0],
            [0,1,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,1,0],
            [0,1,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,1,0],
            [0,1,1,1,1,1,1,0,0,1,1,1,1,0,0,1,1,1,1,0,0,1,1,1,1,1,1,0],
            [0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0],
            [0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0],
            [0,0,0,0,0,0,1,0,0,1,1,1,1,1,1,1,1,1,1,0,0,1,0,0,0,0,0,0],
            [0,0,0,0,0,0,1,0,0,1,0,0,0,3,3,0,0,0,1,0,0,1,0,0,0,0,0,0],
            [0,0,0,0,0,0,1,0,0,1,0,3,3,3,3,3,3,0,1,0,0,1,0,0,0,0,0,0],
            [3,1,1,1,1,1,1,1,1,1,0,3,3,3,3,3,3,0,1,1,1,1,1,1,1,1,1,3],
            [0,0,0,0,0,0,1,0,0,1,0,3,3,3,3,3,3,0,1,0,0,1,0,0,0,0,0,0],
            [0,0,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,0,0],
            [0,0,0,0,0,0,1,0,0,1,1,1,1,1,1,1,1,1,1,0,0,1,0,0,0,0,0,0],
            [0,0,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,0,0],
            [0,0,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,0,0],
            [0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,0],
            [0,1,0,0,0,0,1,0,0,0,0,0,1,0,0,1,0,0,0,0,0,1,0,0,0,0,1,0],
            [0,1,0,0,0,0,1,0,0,0,0,0,1,0,0,1,0,0,0,0,0,1,0,0,0,0,1,0],
            [0,2,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,2,0],
            [0,0,0,1,0,0,1,0,0,1,0,0,0,0,0,0,0,0,1,0,0,1,0,0,1,0,0,0],
            [0,0,0,1,0,0,1,0,0,1,0,0,0,0,0,0,0,0,1,0,0,1,0,0,1,0,0,0],
            [0,1,1,1,1,1,1,0,0,1,1,1,1,0,0,1,1,1,1,0,0,1,1,1,1,1,1,0],
            [0,1,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,1,0],
            [0,1,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,1,0],
            [0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0],
            [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
        ];

        const GRID_WIDTH = 28;
        const GRID_HEIGHT = 31;
        const CELL_SIZE = 20;

        let startPos = { x: 14, y: 23 }; // Pac-Man start position
        let goalPos = { x: 14, y: 11 };  // Ghost start position

        let openSet = new Set();
        let closedSet = new Set();
        let cameFrom = new Map();
        let gScore = new Map();
        let fScore = new Map();
        let finalPath = [];
        let currentNode = null;
        let searching = false;
        let searchComplete = false;
        let animationInterval = null;
        let nodesEvaluated = 0;

        function heuristic(a, b) {
            return Math.abs(a.x - b.x) + Math.abs(a.y - b.y);
        }

        function posKey(pos) {
            return `${pos.x},${pos.y}`;
        }

        function isWalkable(pos) {
            if (pos.y < 0 || pos.y >= GRID_HEIGHT || pos.x < 0 || pos.x >= GRID_WIDTH) return false;
            return MAZE[pos.y][pos.x] !== 0;
        }

        function getNeighbors(pos) {
            const neighbors = [];
            const directions = [
                { x: 0, y: -1 },
                { x: 0, y: 1 },
                { x: -1, y: 0 },
                { x: 1, y: 0 }
            ];
            for (const dir of directions) {
                const nx = pos.x + dir.x;
                const ny = pos.y + dir.y;
                if (isWalkable({ x: nx, y: ny })) {
                    neighbors.push({ x: nx, y: ny });
                }
            }
            return neighbors;
        }

        function reconstructPath(current) {
            const path = [current];
            let key = posKey(current);
            while (cameFrom.has(key)) {
                const prev = cameFrom.get(key);
                path.unshift(prev);
                key = posKey(prev);
            }
            return path;
        }

        function initSearch() {
            openSet = new Set([posKey(startPos)]);
            closedSet = new Set();
            cameFrom = new Map();
            gScore = new Map();
            fScore = new Map();
            finalPath = [];
            currentNode = null;
            searching = true;
            searchComplete = false;
            nodesEvaluated = 0;

            gScore.set(posKey(startPos), 0);
            fScore.set(posKey(startPos), heuristic(startPos, goalPos));

            updateStats();
        }

        function stepSearch() {
            if (!searching || searchComplete || openSet.size === 0) {
                if (openSet.size === 0 && !searchComplete) {
                    document.getElementById('status').textContent = 'No path found!';
                    searching = false;
                }
                return false;
            }

            let lowestF = Infinity;
            let current = null;
            for (const key of openSet) {
                const f = fScore.get(key) ?? Infinity;
                if (f < lowestF) {
                    lowestF = f;
                    const [x, y] = key.split(',').map(Number);
                    current = { x, y };
                }
            }

            if (!current) {
                searching = false;
                return false;
            }

            currentNode = current;
            const currentKey = posKey(current);
            nodesEvaluated++;

            if (current.x === goalPos.x && current.y === goalPos.y) {
                finalPath = reconstructPath(current);
                searching = false;
                searchComplete = true;
                document.getElementById('status').textContent = 'Path found!';
                updateStats();
                draw();
                return false;
            }

            openSet.delete(currentKey);
            closedSet.add(currentKey);

            const neighbors = getNeighbors(current);
            for (const neighbor of neighbors) {
                const neighborKey = posKey(neighbor);

                if (closedSet.has(neighborKey)) continue;

                const tentativeG = (gScore.get(currentKey) ?? Infinity) + 1;

                if (tentativeG < (gScore.get(neighborKey) ?? Infinity)) {
                    cameFrom.set(neighborKey, current);
                    gScore.set(neighborKey, tentativeG);
                    fScore.set(neighborKey, tentativeG + heuristic(neighbor, goalPos));
                    openSet.add(neighborKey);
                }
            }

            updateStats();
            draw();
            return true;
        }

        function updateStats() {
            document.getElementById('nodesEvaluated').textContent = nodesEvaluated;
            document.getElementById('pathLength').textContent = finalPath.length > 0 ? finalPath.length - 1 : '-';
            if (searching) {
                document.getElementById('status').textContent = 'Searching...';
            } else if (searchComplete) {
                document.getElementById('status').textContent = 'Complete!';
            }
        }

        function draw() {
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw maze
            for (let y = 0; y < GRID_HEIGHT; y++) {
                for (let x = 0; x < GRID_WIDTH; x++) {
                    const cell = MAZE[y][x];
                    const px = x * CELL_SIZE;
                    const py = y * CELL_SIZE;

                    if (cell === 3) {
                        // Ghost house
                        ctx.fillStyle = '#444444';
                        ctx.fillRect(px, py, CELL_SIZE, CELL_SIZE);
                    }
                }
            }

            // Draw walls
            ctx.strokeStyle = '#2121de';
            ctx.lineWidth = 3;
            for (let y = 0; y < GRID_HEIGHT; y++) {
                for (let x = 0; x < GRID_WIDTH; x++) {
                    if (MAZE[y][x] === 0) {
                        const px = x * CELL_SIZE;
                        const py = y * CELL_SIZE;

                        const top = y > 0 && MAZE[y - 1][x] !== 0;
                        const bottom = y < GRID_HEIGHT - 1 && MAZE[y + 1][x] !== 0;
                        const left = x > 0 && MAZE[y][x - 1] !== 0;
                        const right = x < GRID_WIDTH - 1 && MAZE[y][x + 1] !== 0;

                        if (top) {
                            ctx.beginPath();
                            ctx.moveTo(px, py);
                            ctx.lineTo(px + CELL_SIZE, py);
                            ctx.stroke();
                        }
                        if (bottom) {
                            ctx.beginPath();
                            ctx.moveTo(px, py + CELL_SIZE);
                            ctx.lineTo(px + CELL_SIZE, py + CELL_SIZE);
                            ctx.stroke();
                        }
                        if (left) {
                            ctx.beginPath();
                            ctx.moveTo(px, py);
                            ctx.lineTo(px, py + CELL_SIZE);
                            ctx.stroke();
                        }
                        if (right) {
                            ctx.beginPath();
                            ctx.moveTo(px + CELL_SIZE, py);
                            ctx.lineTo(px + CELL_SIZE, py + CELL_SIZE);
                            ctx.stroke();
                        }
                    }
                }
            }

            // Draw closed set (explored)
            for (const key of closedSet) {
                const [x, y] = key.split(',').map(Number);
                ctx.fillStyle = 'rgba(0, 255, 255, 0.3)';
                ctx.fillRect(x * CELL_SIZE, y * CELL_SIZE, CELL_SIZE, CELL_SIZE);
            }

            // Draw open set (frontier)
            for (const key of openSet) {
                const [x, y] = key.split(',').map(Number);
                ctx.fillStyle = 'rgba(255, 255, 0, 0.3)';
                ctx.fillRect(x * CELL_SIZE, y * CELL_SIZE, CELL_SIZE, CELL_SIZE);
            }

            // Draw final path
            if (finalPath.length > 0) {
                ctx.strokeStyle = '#0f0';
                ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.moveTo(finalPath[0].x * CELL_SIZE + CELL_SIZE / 2,
                          finalPath[0].y * CELL_SIZE + CELL_SIZE / 2);
                for (let i = 1; i < finalPath.length; i++) {
                    ctx.lineTo(finalPath[i].x * CELL_SIZE + CELL_SIZE / 2,
                              finalPath[i].y * CELL_SIZE + CELL_SIZE / 2);
                }
                ctx.stroke();
            }

            // Draw start (Pac-Man)
            ctx.fillStyle = '#ffff00';
            ctx.beginPath();
            ctx.arc(startPos.x * CELL_SIZE + CELL_SIZE / 2,
                   startPos.y * CELL_SIZE + CELL_SIZE / 2,
                   CELL_SIZE / 3, 0.2 * Math.PI, 1.8 * Math.PI);
            ctx.lineTo(startPos.x * CELL_SIZE + CELL_SIZE / 2,
                      startPos.y * CELL_SIZE + CELL_SIZE / 2);
            ctx.fill();

            // Draw goal (Ghost - simplified)
            ctx.fillStyle = '#0000ff';
            ctx.beginPath();
            ctx.arc(goalPos.x * CELL_SIZE + CELL_SIZE / 2,
                   goalPos.y * CELL_SIZE + CELL_SIZE / 2,
                   CELL_SIZE / 3, Math.PI, 0);
            ctx.lineTo(goalPos.x * CELL_SIZE + CELL_SIZE / 2 + CELL_SIZE / 3,
                      goalPos.y * CELL_SIZE + CELL_SIZE / 2 + CELL_SIZE / 3);
            ctx.lineTo(goalPos.x * CELL_SIZE + CELL_SIZE / 2,
                      goalPos.y * CELL_SIZE + CELL_SIZE / 2);
            ctx.lineTo(goalPos.x * CELL_SIZE + CELL_SIZE / 2 - CELL_SIZE / 3,
                      goalPos.y * CELL_SIZE + CELL_SIZE / 2 + CELL_SIZE / 3);
            ctx.closePath();
            ctx.fill();
        }

        function startSearch() {
            if (animationInterval) {
                clearInterval(animationInterval);
            }
            initSearch();
            const speed = parseInt(document.getElementById('speedControl').value);
            if (speed === 0) {
                while (stepSearch()) {}
            } else {
                animationInterval = setInterval(() => {
                    if (!stepSearch()) {
                        clearInterval(animationInterval);
                    }
                }, speed);
            }
        }

        function resetSearch() {
            if (animationInterval) {
                clearInterval(animationInterval);
            }
            openSet = new Set();
            closedSet = new Set();
            cameFrom = new Map();
            gScore = new Map();
            fScore = new Map();
            finalPath = [];
            currentNode = null;
            searching = false;
            searchComplete = false;
            nodesEvaluated = 0;
            document.getElementById('status').textContent = 'Ready';
            updateStats();
            draw();
        }

        function randomizePoints() {
            // Find random walkable positions
            do {
                startPos = {
                    x: Math.floor(Math.random() * GRID_WIDTH),
                    y: Math.floor(Math.random() * GRID_HEIGHT)
                };
            } while (!isWalkable(startPos));

            do {
                goalPos = {
                    x: Math.floor(Math.random() * GRID_WIDTH),
                    y: Math.floor(Math.random() * GRID_HEIGHT)
                };
            } while (!isWalkable(goalPos) || (goalPos.x === startPos.x && goalPos.y === startPos.y));

            resetSearch();
        }

        // Initialize
        draw();
    </script>
</body>
</html>
