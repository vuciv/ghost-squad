<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Training Replay Viewer - Ghost Squad</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Press Start 2P', 'Courier New', monospace;
            background: #000;
            color: #fff;
            padding: 20px;
            overflow-x: hidden;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        header {
            text-align: center;
            margin-bottom: 30px;
        }

        h1 {
            font-size: 28px;
            color: #ffff00;
            text-shadow: 3px 3px 0px #ff0000;
            margin-bottom: 10px;
        }

        .subtitle {
            font-size: 10px;
            color: #0ff;
            margin-bottom: 20px;
        }

        .controls {
            background: rgba(0, 0, 0, 0.95);
            border: 4px solid #00f;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
            display: flex;
            gap: 15px;
            align-items: center;
            flex-wrap: wrap;
        }

        .file-input-wrapper {
            position: relative;
        }

        input[type="file"] {
            display: none;
        }

        .file-label {
            display: inline-block;
            padding: 15px 20px;
            background: #00f;
            border: 3px solid #fff;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 10px;
            text-transform: uppercase;
            color: #fff;
        }

        .file-label:hover {
            background: #00a;
            transform: scale(1.05);
        }

        button {
            padding: 15px 20px;
            background: #f00;
            border: 3px solid #fff;
            border-radius: 5px;
            color: white;
            cursor: pointer;
            font-size: 10px;
            font-family: inherit;
            transition: all 0.2s;
            text-transform: uppercase;
        }

        button:hover:not(:disabled) {
            background: #a00;
            transform: scale(1.05);
        }

        button:disabled {
            background: #333;
            color: #666;
            border-color: #666;
            cursor: not-allowed;
        }

        .slider-container {
            flex: 1;
            min-width: 300px;
        }

        input[type="range"] {
            width: 100%;
        }

        .info-panel {
            background: rgba(0, 0, 0, 0.95);
            border: 4px solid #00f;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
        }

        .info-item {
            text-align: center;
            padding: 10px;
            background: #111;
            border: 2px solid #333;
            border-radius: 5px;
        }

        .info-label {
            font-size: 8px;
            color: #0ff;
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .info-value {
            font-size: 16px;
            font-weight: bold;
            color: #ffff00;
        }

        .game-container {
            background: rgba(0, 0, 0, 0.95);
            border: 4px solid #00f;
            border-radius: 10px;
            padding: 20px;
        }

        #gameCanvas {
            display: block;
            margin: 0 auto;
            border: 4px solid #00f;
            border-radius: 5px;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
            background: #000;
        }

        .legend {
            margin-top: 20px;
            display: flex;
            justify-content: center;
            gap: 20px;
            flex-wrap: wrap;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            color: #fff;
            font-size: 8px;
            padding: 8px 12px;
            background: #111;
            border: 2px solid #333;
            border-radius: 5px;
        }

        .legend-color {
            width: 16px;
            height: 16px;
            border-radius: 50%;
        }

        .speed-control {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 10px;
            color: #0ff;
        }

        .speed-control select {
            padding: 10px 15px;
            background: #111;
            border: 3px solid #666;
            border-radius: 5px;
            color: #fff;
            font-family: inherit;
            font-size: 10px;
            cursor: pointer;
        }

        .speed-control select:focus {
            border-color: #0ff;
            outline: none;
        }

        input[type="range"] {
            flex: 1;
            height: 6px;
            background: #333;
            border-radius: 3px;
            outline: none;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: #0ff;
            cursor: pointer;
            border-radius: 50%;
            border: 3px solid #fff;
        }

        input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: #0ff;
            cursor: pointer;
            border-radius: 50%;
            border: 3px solid #fff;
        }

        #frameInfo {
            font-size: 8px;
            color: #0ff;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>üëª TRAINING REPLAY</h1>
            <p class="subtitle">Watch Your AI Learn!</p>
        </header>

        <div class="controls">
            <div class="file-input-wrapper">
                <label for="fileInput" class="file-label">üìÅ Load Recording</label>
                <input type="file" id="fileInput" accept=".json">
            </div>

            <button id="playBtn" disabled>‚ñ∂Ô∏è Play</button>
            <button id="pauseBtn" disabled>‚è∏Ô∏è Pause</button>
            <button id="restartBtn" disabled>üîÑ Restart</button>

            <div class="speed-control">
                <label>Speed:</label>
                <select id="speedSelect">
                    <option value="0.25">0.25x</option>
                    <option value="0.5">0.5x</option>
                    <option value="1" selected>1x</option>
                    <option value="2">2x</option>
                    <option value="4">4x</option>
                </select>
            </div>

            <div class="slider-container">
                <input type="range" id="frameSlider" min="0" max="100" value="0" disabled>
                <div style="text-align: center; margin-top: 5px;">
                    <span id="frameInfo">Frame 0 / 0</span>
                </div>
            </div>
        </div>

        <div class="info-panel">
            <div class="info-item">
                <div class="info-label">Episode</div>
                <div class="info-value" id="episodeNum">-</div>
            </div>
            <div class="info-item">
                <div class="info-label">Score</div>
                <div class="info-value" id="scoreValue">0</div>
            </div>
            <div class="info-item">
                <div class="info-label">Dots Collected</div>
                <div class="info-value" id="dotsValue">0</div>
            </div>
            <div class="info-item">
                <div class="info-label">Survival Time</div>
                <div class="info-value" id="timeValue">0s</div>
            </div>
            <div class="info-item">
                <div class="info-label">Status</div>
                <div class="info-value" id="statusValue">-</div>
            </div>
            <div class="info-item">
                <div class="info-label">Current Action</div>
                <div class="info-value" id="actionValue">-</div>
            </div>
        </div>

        <div class="game-container">
            <canvas id="gameCanvas"></canvas>
            <div class="legend">
                <div class="legend-item">
                    <div class="legend-color" style="background: #FFD700;"></div>
                    <span>Pacman</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #FF0000;"></div>
                    <span>Blinky (Red)</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #FFB8FF;"></div>
                    <span>Pinky (Pink)</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #00FFFF;"></div>
                    <span>Inky (Cyan)</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #FFB852;"></div>
                    <span>Clyde (Orange)</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #4169E1;"></div>
                    <span>Frightened</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #ffb897;"></div>
                    <span>Dots</span>
                </div>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // Game constants
        const TILE_SIZE = 20;
        const GRID_WIDTH = 28;
        const GRID_HEIGHT = 35;
        
        canvas.width = GRID_WIDTH * TILE_SIZE;
        canvas.height = GRID_HEIGHT * TILE_SIZE;

        // State
        let recording = null;
        let currentFrame = 0;
        let isPlaying = false;
        let playbackSpeed = 1;
        let animationFrame = null;
        let lastFrameTime = 0;

        // Maze layout (same as the game)
        const MAZE_LAYOUT = [
          [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
          [0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,0],
          [0,1,0,0,0,0,1,0,0,0,0,0,1,0,0,1,0,0,0,0,0,1,0,0,0,0,1,0],
          [0,2,0,0,0,0,1,0,0,0,0,0,1,0,0,1,0,0,0,0,0,1,0,0,0,0,2,0],
          [0,1,0,0,0,0,1,0,0,0,0,0,1,0,0,1,0,0,0,0,0,1,0,0,0,0,1,0],
          [0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0],
          [0,1,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,1,0],
          [0,1,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,1,0],
          [0,1,1,1,1,1,1,0,0,1,1,1,1,0,0,1,1,1,1,0,0,1,1,1,1,1,1,0],
          [0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0],
          [0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0],
          [0,0,0,0,0,0,1,0,0,1,1,1,1,1,1,1,1,1,1,0,0,1,0,0,0,0,0,0],
          [0,0,0,0,0,0,1,0,0,1,0,0,0,3,3,0,0,0,1,0,0,1,0,0,0,0,0,0],
          [0,0,0,0,0,0,1,0,0,1,0,3,3,3,3,3,3,0,1,0,0,1,0,0,0,0,0,0],
          [1,1,1,1,1,1,1,1,1,1,0,3,3,3,3,3,3,0,1,1,1,1,1,1,1,1,1,1],
          [0,0,0,0,0,0,1,0,0,1,0,3,3,3,3,3,3,0,1,0,0,1,0,0,0,0,0,0],
          [0,0,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,0,0],
          [0,0,0,0,0,0,1,0,0,1,1,1,1,1,1,1,1,1,1,0,0,1,0,0,0,0,0,0],
          [0,0,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,0,0],
          [0,0,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,0,0],
          [0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,0],
          [0,1,0,0,0,0,1,0,0,0,0,0,1,0,0,1,0,0,0,0,0,1,0,0,0,0,1,0],
          [0,1,0,0,0,0,1,0,0,0,0,0,1,0,0,1,0,0,0,0,0,1,0,0,0,0,1,0],
          [0,2,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,2,0],
          [0,0,0,1,0,0,1,0,0,1,0,0,0,0,0,0,0,0,1,0,0,1,0,0,1,0,0,0],
          [0,0,0,1,0,0,1,0,0,1,0,0,0,0,0,0,0,0,1,0,0,1,0,0,1,0,0,0],
          [0,1,1,1,1,1,1,0,0,1,1,1,1,0,0,1,1,1,1,0,0,1,1,1,1,1,1,0],
          [0,1,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,1,0],
          [0,1,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,1,0],
          [0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0],
          [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
        ];

        // UI Elements
        const playBtn = document.getElementById('playBtn');
        const pauseBtn = document.getElementById('pauseBtn');
        const restartBtn = document.getElementById('restartBtn');
        const frameSlider = document.getElementById('frameSlider');
        const speedSelect = document.getElementById('speedSelect');
        const fileInput = document.getElementById('fileInput');

        // Load file
        fileInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (event) => {
                try {
                    recording = JSON.parse(event.target.result);
                    loadRecording();
                } catch (error) {
                    alert('Error loading recording: ' + error.message);
                }
            };
            reader.readAsText(file);
        });

        function loadRecording() {
            if (!recording) return;

            currentFrame = 0;
            frameSlider.max = recording.frames.length - 1;
            frameSlider.value = 0;
            frameSlider.disabled = false;

            playBtn.disabled = false;
            pauseBtn.disabled = false;
            restartBtn.disabled = false;

            // Update info - handle both old and adversarial format
            document.getElementById('episodeNum').textContent = recording.episode;

            // Check if this is adversarial training format (has recording.result field)
            if (recording.result) {
                // Adversarial format
                const firstFrame = recording.frames[0];
                const lastFrame = recording.frames[recording.frames.length - 1];
                const dotsCollected = firstFrame.dots.length - lastFrame.dots.length;

                document.getElementById('dotsValue').textContent = dotsCollected;
                document.getElementById('timeValue').textContent = (recording.steps / 60).toFixed(1) + 's';

                let status = recording.result === 'PACMAN_WIN' ? 'üèÜ PACMAN WIN' :
                            recording.result === 'CAUGHT_BY_GHOST' ? 'üëª GHOST WIN' :
                            '‚è±Ô∏è TIMEOUT';
                document.getElementById('statusValue').textContent = status;
            } else {
                // Original format
                document.getElementById('dotsValue').textContent = recording.dotsCollected || 0;
                document.getElementById('timeValue').textContent = ((recording.survivalTime || 0) / 1000).toFixed(1) + 's';

                let status = recording.won ? 'üèÜ WIN' : recording.died ? 'üíÄ DIED' : '‚è±Ô∏è TIMEOUT';
                document.getElementById('statusValue').textContent = status;
            }

            renderFrame(0);
        }

        playBtn.addEventListener('click', () => {
            isPlaying = true;
            lastFrameTime = performance.now();
            animate();
        });

        pauseBtn.addEventListener('click', () => {
            isPlaying = false;
            if (animationFrame) {
                cancelAnimationFrame(animationFrame);
            }
        });

        restartBtn.addEventListener('click', () => {
            currentFrame = 0;
            frameSlider.value = 0;
            renderFrame(0);
        });

        frameSlider.addEventListener('input', (e) => {
            currentFrame = parseInt(e.target.value);
            renderFrame(currentFrame);
        });

        speedSelect.addEventListener('change', (e) => {
            playbackSpeed = parseFloat(e.target.value);
        });

        function animate() {
            if (!isPlaying) return;

            const now = performance.now();
            const deltaTime = now - lastFrameTime;
            
            // Target: 60 FPS base, adjusted by playback speed
            const frameTime = (1000 / 60) / playbackSpeed;
            
            if (deltaTime >= frameTime) {
                lastFrameTime = now;
                
                currentFrame++;
                if (currentFrame >= recording.frames.length) {
                    currentFrame = recording.frames.length - 1;
                    isPlaying = false;
                    return;
                }

                frameSlider.value = currentFrame;
                renderFrame(currentFrame);
            }

            animationFrame = requestAnimationFrame(animate);
        }

        function renderFrame(frameIndex) {
            if (!recording || !recording.frames[frameIndex]) return;

            const frame = recording.frames[frameIndex];

            // Handle both formats: adversarial (frame.pacman) vs original (frame.state)
            let state;
            if (frame.pacman) {
                // Adversarial format - convert to state format
                state = {
                    position: frame.pacman.position,
                    direction: frame.pacman.direction,
                    dots: frame.dots,
                    powerPellets: frame.powerPellets,
                    ghosts: frame.ghosts,
                    score: frame.score
                };
            } else {
                // Original format
                state = frame.state;
            }

            // Clear canvas
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw maze walls (exactly like the game)
            ctx.strokeStyle = '#2121de'; // Classic Pacman blue
            ctx.lineWidth = 3;

            for (let y = 0; y < MAZE_LAYOUT.length; y++) {
                for (let x = 0; x < MAZE_LAYOUT[y].length; x++) {
                    const cell = MAZE_LAYOUT[y][x];
                    const px = x * TILE_SIZE;
                    const py = y * TILE_SIZE;

                    if (cell === 0) {
                        // Wall - draw borders where adjacent to walkable space
                        const top = y > 0 && MAZE_LAYOUT[y - 1][x] !== 0;
                        const bottom = y < MAZE_LAYOUT.length - 1 && MAZE_LAYOUT[y + 1][x] !== 0;
                        const left = x > 0 && MAZE_LAYOUT[y][x - 1] !== 0;
                        const right = x < MAZE_LAYOUT[y].length - 1 && MAZE_LAYOUT[y][x + 1] !== 0;

                        ctx.beginPath();
                        if (top) {
                            ctx.moveTo(px, py);
                            ctx.lineTo(px + TILE_SIZE, py);
                        }
                        if (bottom) {
                            ctx.moveTo(px, py + TILE_SIZE);
                            ctx.lineTo(px + TILE_SIZE, py + TILE_SIZE);
                        }
                        if (left) {
                            ctx.moveTo(px, py);
                            ctx.lineTo(px, py + TILE_SIZE);
                        }
                        if (right) {
                            ctx.moveTo(px + TILE_SIZE, py);
                            ctx.lineTo(px + TILE_SIZE, py + TILE_SIZE);
                        }
                        ctx.stroke();
                    } else if (cell === 3) {
                        // Ghost house - slightly darker
                        ctx.fillStyle = 'rgba(68, 68, 68, 0.3)';
                        ctx.fillRect(px, py, TILE_SIZE, TILE_SIZE);
                    }
                }
            }

            // Draw dots (same peachy color as game)
            ctx.fillStyle = '#ffb897';
            for (const dot of state.dots) {
                ctx.beginPath();
                ctx.arc(
                    dot.x * TILE_SIZE + TILE_SIZE / 2,
                    dot.y * TILE_SIZE + TILE_SIZE / 2,
                    2, 0, Math.PI * 2
                );
                ctx.fill();
            }

            // Draw power pellets (same peachy color, larger)
            ctx.fillStyle = '#ffb897';
            for (const pellet of state.powerPellets) {
                ctx.beginPath();
                ctx.arc(
                    pellet.x * TILE_SIZE + TILE_SIZE / 2,
                    pellet.y * TILE_SIZE + TILE_SIZE / 2,
                    6, 0, Math.PI * 2
                );
                ctx.fill();
            }

            // Draw ghosts (exactly like the game)
            for (let i = 0; i < state.ghosts.length; i++) {
                const ghost = state.ghosts[i];
                const gx = ghost.position.x * TILE_SIZE + TILE_SIZE / 2;
                const gy = ghost.position.y * TILE_SIZE + TILE_SIZE / 2;
                
                // Ghost body color based on frightened state
                if (ghost.isFrightened) {
                    ctx.fillStyle = '#4169E1'; // Blue when frightened
                } else {
                    // Different colors for each ghost (like classic Pacman)
                    const colors = ['#FF0000', '#FFB8FF', '#00FFFF', '#FFB852']; // Red, Pink, Cyan, Orange
                    ctx.fillStyle = colors[i % colors.length];
                }
                
                // Draw ghost body (rounded top, wavy bottom)
                ctx.beginPath();
                ctx.arc(gx, gy - 2, 8, Math.PI, 0, false); // Top semicircle
                ctx.lineTo(gx + 8, gy + 6); // Right side
                
                // Wavy bottom (3 humps)
                ctx.lineTo(gx + 5, gy + 6);
                ctx.lineTo(gx + 5, gy + 8);
                ctx.lineTo(gx + 2.5, gy + 6);
                ctx.lineTo(gx, gy + 8);
                ctx.lineTo(gx - 2.5, gy + 6);
                ctx.lineTo(gx - 5, gy + 8);
                ctx.lineTo(gx - 5, gy + 6);
                
                ctx.lineTo(gx - 8, gy + 6); // Left side
                ctx.closePath();
                ctx.fill();

                if (!ghost.isFrightened) {
                    // Draw white eyes
                    ctx.fillStyle = '#FFF';
                    ctx.beginPath();
                    ctx.arc(gx - 3, gy - 2, 3, 0, Math.PI * 2);
                    ctx.arc(gx + 3, gy - 2, 3, 0, Math.PI * 2);
                    ctx.fill();

                    // Draw pupils (looking in movement direction)
                    ctx.fillStyle = '#000';
                    let pupilOffsetX = 0;
                    let pupilOffsetY = 0;
                    
                    switch(ghost.direction) {
                        case 'LEFT':
                            pupilOffsetX = -1.5;
                            break;
                        case 'RIGHT':
                            pupilOffsetX = 1.5;
                            break;
                        case 'UP':
                            pupilOffsetY = -1.5;
                            break;
                        case 'DOWN':
                            pupilOffsetY = 1.5;
                            break;
                    }
                    
                    ctx.beginPath();
                    ctx.arc(gx - 3 + pupilOffsetX, gy - 2 + pupilOffsetY, 1.5, 0, Math.PI * 2);
                    ctx.arc(gx + 3 + pupilOffsetX, gy - 2 + pupilOffsetY, 1.5, 0, Math.PI * 2);
                    ctx.fill();
                } else {
                    // Frightened mode - draw scared face
                    ctx.fillStyle = '#FFF';
                    // Squiggly mouth
                    ctx.beginPath();
                    ctx.arc(gx - 2, gy + 2, 1, 0, Math.PI * 2);
                    ctx.arc(gx + 2, gy + 2, 1, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            // Draw Pacman
            ctx.fillStyle = '#FFD700';
            ctx.beginPath();
            
            // Calculate mouth angle based on direction
            let startAngle = 0.2 * Math.PI;
            let endAngle = 1.8 * Math.PI;
            
            switch(state.direction) {
                case 'RIGHT':
                    startAngle = 0.2 * Math.PI;
                    endAngle = 1.8 * Math.PI;
                    break;
                case 'LEFT':
                    startAngle = 1.2 * Math.PI;
                    endAngle = 0.8 * Math.PI;
                    break;
                case 'UP':
                    startAngle = 1.7 * Math.PI;
                    endAngle = 1.3 * Math.PI;
                    break;
                case 'DOWN':
                    startAngle = 0.7 * Math.PI;
                    endAngle = 0.3 * Math.PI;
                    break;
            }
            
            ctx.arc(
                state.position.x * TILE_SIZE + TILE_SIZE / 2,
                state.position.y * TILE_SIZE + TILE_SIZE / 2,
                10, startAngle, endAngle
            );
            ctx.lineTo(
                state.position.x * TILE_SIZE + TILE_SIZE / 2,
                state.position.y * TILE_SIZE + TILE_SIZE / 2
            );
            ctx.fill();

            // Update info
            document.getElementById('scoreValue').textContent = state.score;
            document.getElementById('actionValue').textContent = frame.action || state.direction;
            document.getElementById('frameInfo').textContent =
                `Frame ${frameIndex + 1} / ${recording.frames.length}`;
        }
    </script>
</body>
</html>

