<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Predictive Lookahead Algorithm - Pac-Man AI Visualization</title>
    <style>
        body {
            font-family: 'Courier New', monospace;
            background: #000;
            color: #0f0;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            margin: 0;
        }
        h1 {
            color: #ff0;
            text-shadow: 0 0 10px #ff0;
            margin-bottom: 10px;
        }
        .description {
            max-width: 900px;
            text-align: center;
            margin-bottom: 20px;
            line-height: 1.6;
            color: #0ff;
        }
        .controls {
            margin: 20px 0;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            justify-content: center;
            align-items: center;
        }
        button {
            background: #222;
            color: #0f0;
            border: 2px solid #0f0;
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            transition: all 0.3s;
        }
        button:hover:not(:disabled) {
            background: #0f0;
            color: #000;
            box-shadow: 0 0 10px #0f0;
        }
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        label {
            color: #0ff;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        select, input {
            background: #222;
            color: #0f0;
            border: 2px solid #0f0;
            padding: 5px 10px;
            font-family: 'Courier New', monospace;
        }
        #canvas {
            border: 3px solid #0f0;
            box-shadow: 0 0 20px #0f0;
            margin: 20px 0;
        }
        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 20px;
            max-width: 900px;
            width: 100%;
        }
        .stat-box {
            background: #001100;
            border: 2px solid #0f0;
            padding: 10px;
            text-align: center;
        }
        .stat-label {
            color: #0ff;
            font-size: 14px;
        }
        .stat-value {
            color: #ff0;
            font-size: 24px;
            font-weight: bold;
        }
        .tree-container {
            margin: 30px 0;
            max-width: 900px;
            overflow-x: auto;
            border: 2px solid #0f0;
            background: #001100;
            padding: 20px;
        }
        .tree-title {
            color: #ff0;
            font-size: 20px;
            margin-bottom: 15px;
            text-align: center;
        }
        .tree-node {
            margin: 5px 0;
            padding: 8px;
            border-left: 2px solid #0f0;
            margin-left: 20px;
        }
        .tree-node.pacman {
            border-left-color: #ff0;
            color: #ff0;
        }
        .tree-node.ghost {
            border-left-color: #f0f;
            color: #f0f;
        }
        .tree-node.best {
            background: rgba(0, 255, 0, 0.1);
            border-left-width: 4px;
        }
        .explanation {
            max-width: 900px;
            text-align: left;
            margin-top: 30px;
            padding: 20px;
            border: 2px solid #0f0;
            background: #001100;
        }
        .explanation h2 {
            color: #ff0;
            margin-top: 20px;
        }
        .explanation h2:first-child {
            margin-top: 0;
        }
        .explanation code {
            color: #0ff;
            background: #002200;
            padding: 2px 6px;
            border-radius: 3px;
        }
        .explanation ul, .explanation ol {
            line-height: 1.8;
        }
        .legend {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            justify-content: center;
            margin: 20px 0;
        }
        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 5px 10px;
            border: 1px solid #0f0;
            background: #001100;
        }
        .legend-color {
            width: 25px;
            height: 25px;
            border: 2px solid #0f0;
        }
    </style>
</head>
<body>
    <h1>PREDICTIVE LOOKAHEAD ALGORITHM</h1>
    <div class="description">
        The core AI that powers Pac-Man's decision making. It explores possible futures by simulating
        Pac-Man's moves and predicting ghost responses, choosing the path that leads to the best outcome.
        <br><strong>Not true Minimax!</strong> Ghosts don't branch - we predict their single "most likely" move.
    </div>

    <div class="controls">
        <button onclick="runLookahead()">Run Lookahead</button>
        <button onclick="stepLookahead()" id="stepBtn">Step Through Tree</button>
        <button onclick="reset()">Reset</button>
        <label>
            Search Depth:
            <input type="number" id="depthInput" value="3" min="1" max="6" style="width: 60px;">
        </label>
        <label>
            Animation Speed:
            <select id="speedControl">
                <option value="1000">Slow</option>
                <option value="500" selected>Medium</option>
                <option value="200">Fast</option>
                <option value="0">Instant</option>
            </select>
        </label>
    </div>

    <canvas id="canvas" width="900" height="400"></canvas>

    <div class="legend">
        <div class="legend-item">
            <div class="legend-color" style="background: #ff0;"></div>
            <span>Pac-Man</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #f00;"></div>
            <span>Ghost</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #0ff;"></div>
            <span>Dot</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: rgba(255, 255, 0, 0.3);"></div>
            <span>Possible Pacman Move</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: rgba(255, 0, 255, 0.3);"></div>
            <span>Predicted Ghost Move</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #0f0;"></div>
            <span>Best Path</span>
        </div>
    </div>

    <div class="stats">
        <div class="stat-box">
            <div class="stat-label">Search Depth</div>
            <div class="stat-value" id="statDepth">3</div>
        </div>
        <div class="stat-box">
            <div class="stat-label">Nodes Evaluated</div>
            <div class="stat-value" id="statNodes">0</div>
        </div>
        <div class="stat-box">
            <div class="stat-label">Best Direction</div>
            <div class="stat-value" id="statDirection">-</div>
        </div>
        <div class="stat-box">
            <div class="stat-label">Best Score</div>
            <div class="stat-value" id="statScore">-</div>
        </div>
    </div>

    <div class="tree-container">
        <div class="tree-title">LOOKAHEAD TREE (Pac-Man branches, Ghosts predicted)</div>
        <div id="treeView"></div>
    </div>

    <div class="explanation">
        <h2>How Predictive Lookahead Works</h2>
        <p>
            Predictive Lookahead is a <strong>simplified version of Minimax</strong> designed for real-time gameplay.
            Instead of exploring all possible ghost moves (which would be computationally explosive),
            it predicts the single "most likely" ghost move at each step.
        </p>

        <h2>The Algorithm</h2>
        <ol>
            <li><strong>Pac-Man's Turn (Maximizing):</strong>
                <ul>
                    <li>Try ALL 4 possible directions (UP, DOWN, LEFT, RIGHT)</li>
                    <li>For each valid move, simulate the game state</li>
                    <li>Recursively evaluate the resulting position</li>
                    <li>Choose the move with the highest score</li>
                </ul>
            </li>
            <li><strong>Ghost Prediction (Minimizing - but single path!):</strong>
                <ul>
                    <li>For each ghost, predict its MOST LIKELY next move</li>
                    <li>Ghosts prefer to continue in their current direction (inertia)</li>
                    <li>If blocked, they move toward Pac-Man</li>
                    <li>Check for collisions/swaps with predicted positions</li>
                    <li><strong>No branching - just one predicted outcome</strong></li>
                </ul>
            </li>
            <li><strong>Base Cases:</strong>
                <ul>
                    <li>Reached maximum depth → evaluate position</li>
                    <li>All dots eaten → WIN (return ∞)</li>
                    <li>Collision with ghost → DEATH (return -∞)</li>
                </ul>
            </li>
        </ol>

        <h2>Why NOT True Minimax?</h2>
        <p>
            True Minimax would explore ALL possible ghost move combinations. With 4 ghosts and 4 possible
            moves each, that's <code>4^4 = 256</code> branches per ghost turn!
        </p>
        <p>
            At depth 12 (our default), this would mean evaluating <strong>millions of nodes</strong> per decision,
            which is impossible in real-time. By predicting a single ghost path, we reduce the tree to manageable size
            while still achieving excellent gameplay.
        </p>

        <h2>Key Differences from Minimax</h2>
        <table style="width: 100%; border-collapse: collapse; margin-top: 10px;">
            <tr style="background: #002200;">
                <th style="border: 1px solid #0f0; padding: 10px; color: #ff0;">Aspect</th>
                <th style="border: 1px solid #0f0; padding: 10px; color: #ff0;">True Minimax</th>
                <th style="border: 1px solid #0f0; padding: 10px; color: #ff0;">Predictive Lookahead</th>
            </tr>
            <tr>
                <td style="border: 1px solid #0f0; padding: 10px;">Ghost Moves</td>
                <td style="border: 1px solid #0f0; padding: 10px;">Explores ALL combinations</td>
                <td style="border: 1px solid #0f0; padding: 10px;">Predicts ONE most likely</td>
            </tr>
            <tr>
                <td style="border: 1px solid #0f0; padding: 10px;">Tree Branching</td>
                <td style="border: 1px solid #0f0; padding: 10px;">4^n for Pac-Man, 4^m for each ghost layer</td>
                <td style="border: 1px solid #0f0; padding: 10px;">4^n for Pac-Man only</td>
            </tr>
            <tr>
                <td style="border: 1px solid #0f0; padding: 10px;">Nodes at Depth 12</td>
                <td style="border: 1px solid #0f0; padding: 10px;">~16 million (infeasible)</td>
                <td style="border: 1px solid #0f0; padding: 10px;">~8,000 (very fast)</td>
            </tr>
            <tr>
                <td style="border: 1px solid #0f0; padding: 10px;">Optimality</td>
                <td style="border: 1px solid #0f0; padding: 10px;">Perfect against optimal ghosts</td>
                <td style="border: 1px solid #0f0; padding: 10px;">Near-optimal against realistic ghosts</td>
            </tr>
            <tr>
                <td style="border: 1px solid #0f0; padding: 10px;">Real-time Performance</td>
                <td style="border: 1px solid #0f0; padding: 10px;">❌ Too slow (seconds/move)</td>
                <td style="border: 1px solid #0f0; padding: 10px;">✅ Very fast (10-50ms/move)</td>
            </tr>
        </table>

        <h2>Position Evaluation Heuristics</h2>
        <p>At each leaf node (or when depth limit is reached), we evaluate the position using:</p>
        <ul>
            <li><strong>Ghost Danger:</strong> Exponential penalty for proximity to ghosts</li>
            <li><strong>Progress Score:</strong> Reward for eating dots during simulation</li>
            <li><strong>Distance to Food:</strong> Pull toward nearest pellet</li>
            <li><strong>Frightened Ghost Bonus:</strong> Chase value when ghosts are vulnerable</li>
            <li><strong>Power Pellet Urgency:</strong> Critical value when ghosts are near</li>
            <li><strong>Positional Advantage:</strong> Reward for open space (escape routes)</li>
            <li><strong>Choke Point Danger:</strong> Penalty if ghosts control intersections</li>
            <li><strong>Exploration Bonus:</strong> Incentive to move when no nearby pellets</li>
        </ul>

        <h2>Alpha-Beta Pruning</h2>
        <p>
            Even though we only predict one ghost path, we still use alpha-beta pruning to cut off
            branches that can't possibly be better than what we've already found. This makes the search
            even faster without losing any accuracy.
        </p>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        // Simple grid
        const GRID_SIZE = 50;
        const COLS = 18;
        const ROWS = 8;

        let pacmanPos = { x: 2, y: 4 };
        let ghostPos = { x: 15, y: 4 };
        let dots = [
            { x: 5, y: 4 }, { x: 6, y: 4 }, { x: 7, y: 4 },
            { x: 10, y: 4 }, { x: 11, y: 4 }, { x: 12, y: 4 }
        ];

        let searchTree = [];
        let bestPath = [];
        let currentStep = 0;
        let isAnimating = false;
        let nodesEvaluated = 0;

        const DIRECTIONS = {
            UP: { x: 0, y: -1 },
            DOWN: { x: 0, y: 1 },
            LEFT: { x: -1, y: 0 },
            RIGHT: { x: 1, y: 0 }
        };

        function heuristic(a, b) {
            return Math.abs(a.x - b.x) + Math.abs(a.y - b.y);
        }

        function isValidPos(pos) {
            return pos.x >= 0 && pos.x < COLS && pos.y >= 0 && pos.y < ROWS;
        }

        function moveInDirection(pos, dir) {
            return {
                x: pos.x + DIRECTIONS[dir].x,
                y: pos.y + DIRECTIONS[dir].y
            };
        }

        function evaluatePosition(pacPos, ghostPos, dots) {
            nodesEvaluated++;
            let score = 0;

            // Ghost danger
            const ghostDist = heuristic(pacPos, ghostPos);
            if (ghostDist <= 1) return -100000; // Death
            score -= 500 / (ghostDist + 1);

            // Dots eaten
            const dotsRemaining = dots.filter(d => !(d.x === pacPos.x && d.y === pacPos.y)).length;
            score += (6 - dotsRemaining) * 100;

            // Distance to nearest dot
            let minDotDist = Infinity;
            for (const dot of dots) {
                const dist = heuristic(pacPos, dot);
                minDotDist = Math.min(minDotDist, dist);
            }
            score -= minDotDist * 5;

            return score;
        }

        function predictGhostMove(ghostPos, pacPos) {
            // Simple: move toward Pac-Man
            const validMoves = [];
            for (const dir in DIRECTIONS) {
                const newPos = moveInDirection(ghostPos, dir);
                if (isValidPos(newPos)) {
                    validMoves.push({ dir, pos: newPos, dist: heuristic(newPos, pacPos) });
                }
            }
            validMoves.sort((a, b) => a.dist - b.dist);
            return validMoves[0]?.pos || ghostPos;
        }

        function predictiveLookahead(state, depth, alpha, beta, isPacmanTurn, path = []) {
            // Base cases
            if (depth === 0 || state.dots.length === 0) {
                return {
                    score: evaluatePosition(state.pacmanPos, state.ghostPos, state.dots),
                    path: path
                };
            }

            if (isPacmanTurn) {
                // Pac-Man maximizes
                let maxEval = { score: -Infinity, path: [] };

                for (const dir in DIRECTIONS) {
                    const newPacPos = moveInDirection(state.pacmanPos, dir);
                    if (!isValidPos(newPacPos)) continue;

                    // Simulate move
                    const newDots = state.dots.filter(d => !(d.x === newPacPos.x && d.y === newPacPos.y));
                    const newState = {
                        pacmanPos: newPacPos,
                        ghostPos: state.ghostPos,
                        dots: newDots
                    };

                    const newPath = [...path, { type: 'pacman', dir, pos: newPacPos, score: 0 }];
                    const evaluation = predictiveLookahead(newState, depth - 1, alpha, beta, false, newPath);

                    if (evaluation.score > maxEval.score) {
                        maxEval = evaluation;
                        maxEval.path[path.length] = { ...newPath[path.length], score: evaluation.score };
                    }

                    alpha = Math.max(alpha, evaluation.score);
                    if (beta <= alpha) break; // Prune
                }

                return maxEval;
            } else {
                // Predict ghost move (single path, no branching)
                const newGhostPos = predictGhostMove(state.ghostPos, state.pacmanPos);
                const newState = {
                    pacmanPos: state.pacmanPos,
                    ghostPos: newGhostPos,
                    dots: state.dots
                };

                const newPath = [...path, { type: 'ghost', pos: newGhostPos, score: 0 }];
                return predictiveLookahead(newState, depth - 1, alpha, beta, true, newPath);
            }
        }

        function runLookahead() {
            reset();
            const depth = parseInt(document.getElementById('depthInput').value);
            document.getElementById('statDepth').textContent = depth;
            nodesEvaluated = 0;

            const initialState = {
                pacmanPos: { ...pacmanPos },
                ghostPos: { ...ghostPos },
                dots: dots.map(d => ({ ...d }))
            };

            const result = predictiveLookahead(initialState, depth, -Infinity, Infinity, true);

            bestPath = result.path || [];
            document.getElementById('statNodes').textContent = nodesEvaluated;
            document.getElementById('statScore').textContent = result.score.toFixed(0);

            if (bestPath.length > 0) {
                document.getElementById('statDirection').textContent = bestPath[0].dir || '-';
            }

            renderTree();

            const speed = parseInt(document.getElementById('speedControl').value);
            if (speed === 0) {
                // Instant - show final result
                currentStep = bestPath.length;
                draw();
            } else {
                animatePath();
            }
        }

        function animatePath() {
            if (currentStep >= bestPath.length) {
                isAnimating = false;
                return;
            }

            isAnimating = true;
            draw();
            currentStep++;

            const speed = parseInt(document.getElementById('speedControl').value);
            setTimeout(animatePath, speed);
        }

        function stepLookahead() {
            if (!bestPath.length) {
                runLookahead();
                currentStep = 0;
                return;
            }
            if (currentStep < bestPath.length) {
                currentStep++;
                draw();
            }
        }

        function reset() {
            currentStep = 0;
            bestPath = [];
            searchTree = [];
            nodesEvaluated = 0;
            isAnimating = false;
            document.getElementById('statDirection').textContent = '-';
            document.getElementById('statScore').textContent = '-';
            document.getElementById('statNodes').textContent = '0';
            document.getElementById('treeView').innerHTML = '<div style="color: #777;">Run lookahead to see the search tree...</div>';
            draw();
        }

        function renderTree() {
            const treeView = document.getElementById('treeView');
            treeView.innerHTML = '';

            if (bestPath.length === 0) {
                treeView.innerHTML = '<div style="color: #777;">No path found</div>';
                return;
            }

            let html = '<div style="font-family: monospace; line-height: 1.8;">';
            html += '<div style="color: #ff0; font-weight: bold;">ROOT: Pac-Man at (' + pacmanPos.x + ',' + pacmanPos.y + ')</div>';

            let indent = 1;
            for (let i = 0; i < bestPath.length; i++) {
                const node = bestPath[i];
                const indentStr = '│  '.repeat(indent);
                const connector = i === bestPath.length - 1 ? '└─ ' : '├─ ';

                if (node.type === 'pacman') {
                    html += `<div class="tree-node pacman best">
                        ${indentStr}${connector}<strong>PACMAN ${node.dir}</strong> → (${node.pos.x},${node.pos.y})
                        [score: ${node.score ? node.score.toFixed(0) : 'calculating...'}]
                    </div>`;
                    indent++;
                } else {
                    html += `<div class="tree-node ghost">
                        ${indentStr}${connector}<strong>GHOST predicted</strong> → (${node.pos.x},${node.pos.y})
                    </div>`;
                }
            }
            html += '</div>';
            treeView.innerHTML = html;
        }

        function draw() {
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw grid
            ctx.strokeStyle = '#222';
            ctx.lineWidth = 1;
            for (let x = 0; x <= COLS; x++) {
                ctx.beginPath();
                ctx.moveTo(x * GRID_SIZE, 0);
                ctx.lineTo(x * GRID_SIZE, ROWS * GRID_SIZE);
                ctx.stroke();
            }
            for (let y = 0; y <= ROWS; y++) {
                ctx.beginPath();
                ctx.moveTo(0, y * GRID_SIZE);
                ctx.lineTo(COLS * GRID_SIZE, y * GRID_SIZE);
                ctx.stroke();
            }

            // Draw lookahead preview
            if (bestPath.length > 0) {
                let currentPac = { ...pacmanPos };
                let currentGhost = { ...ghostPos };

                for (let i = 0; i < Math.min(currentStep, bestPath.length); i++) {
                    const node = bestPath[i];

                    if (node.type === 'pacman') {
                        // Draw predicted Pac-Man move
                        ctx.fillStyle = 'rgba(255, 255, 0, 0.3)';
                        ctx.fillRect(node.pos.x * GRID_SIZE, node.pos.y * GRID_SIZE, GRID_SIZE, GRID_SIZE);

                        // Draw arrow
                        ctx.strokeStyle = '#ff0';
                        ctx.lineWidth = 3;
                        ctx.beginPath();
                        ctx.moveTo(currentPac.x * GRID_SIZE + GRID_SIZE/2, currentPac.y * GRID_SIZE + GRID_SIZE/2);
                        ctx.lineTo(node.pos.x * GRID_SIZE + GRID_SIZE/2, node.pos.y * GRID_SIZE + GRID_SIZE/2);
                        ctx.stroke();

                        currentPac = node.pos;
                    } else {
                        // Draw predicted ghost move
                        ctx.fillStyle = 'rgba(255, 0, 255, 0.3)';
                        ctx.fillRect(node.pos.x * GRID_SIZE, node.pos.y * GRID_SIZE, GRID_SIZE, GRID_SIZE);

                        // Draw arrow
                        ctx.strokeStyle = '#f0f';
                        ctx.lineWidth = 3;
                        ctx.beginPath();
                        ctx.moveTo(currentGhost.x * GRID_SIZE + GRID_SIZE/2, currentGhost.y * GRID_SIZE + GRID_SIZE/2);
                        ctx.lineTo(node.pos.x * GRID_SIZE + GRID_SIZE/2, node.pos.y * GRID_SIZE + GRID_SIZE/2);
                        ctx.stroke();

                        currentGhost = node.pos;
                    }
                }
            }

            // Draw dots
            for (const dot of dots) {
                ctx.fillStyle = '#0ff';
                ctx.beginPath();
                ctx.arc(dot.x * GRID_SIZE + GRID_SIZE/2, dot.y * GRID_SIZE + GRID_SIZE/2, 8, 0, Math.PI * 2);
                ctx.fill();
            }

            // Draw Pac-Man
            ctx.fillStyle = '#ff0';
            ctx.beginPath();
            ctx.arc(pacmanPos.x * GRID_SIZE + GRID_SIZE/2, pacmanPos.y * GRID_SIZE + GRID_SIZE/2,
                   GRID_SIZE/3, 0.2 * Math.PI, 1.8 * Math.PI);
            ctx.lineTo(pacmanPos.x * GRID_SIZE + GRID_SIZE/2, pacmanPos.y * GRID_SIZE + GRID_SIZE/2);
            ctx.fill();

            // Draw Ghost
            ctx.fillStyle = '#f00';
            ctx.beginPath();
            ctx.arc(ghostPos.x * GRID_SIZE + GRID_SIZE/2, ghostPos.y * GRID_SIZE + GRID_SIZE/2,
                   GRID_SIZE/3, Math.PI, 0);
            ctx.lineTo(ghostPos.x * GRID_SIZE + GRID_SIZE/2 + GRID_SIZE/3, ghostPos.y * GRID_SIZE + GRID_SIZE/2 + GRID_SIZE/3);
            ctx.lineTo(ghostPos.x * GRID_SIZE + GRID_SIZE/2 + GRID_SIZE/6, ghostPos.y * GRID_SIZE + GRID_SIZE/2);
            ctx.lineTo(ghostPos.x * GRID_SIZE + GRID_SIZE/2, ghostPos.y * GRID_SIZE + GRID_SIZE/2 + GRID_SIZE/3);
            ctx.lineTo(ghostPos.x * GRID_SIZE + GRID_SIZE/2 - GRID_SIZE/6, ghostPos.y * GRID_SIZE + GRID_SIZE/2);
            ctx.lineTo(ghostPos.x * GRID_SIZE + GRID_SIZE/2 - GRID_SIZE/3, ghostPos.y * GRID_SIZE + GRID_SIZE/2 + GRID_SIZE/3);
            ctx.closePath();
            ctx.fill();

            // Eyes
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.arc(ghostPos.x * GRID_SIZE + GRID_SIZE/2 - 8, ghostPos.y * GRID_SIZE + GRID_SIZE/2 - 5, 4, 0, Math.PI * 2);
            ctx.arc(ghostPos.x * GRID_SIZE + GRID_SIZE/2 + 8, ghostPos.y * GRID_SIZE + GRID_SIZE/2 - 5, 4, 0, Math.PI * 2);
            ctx.fill();
        }

        // Initialize
        draw();
    </script>
</body>
</html>
